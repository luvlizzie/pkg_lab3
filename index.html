<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Image Processing Lab ‚Äî –û—Å–µ–Ω–Ω—è—è –≤–µ—Ä—Å–∏—è</title>
<style>
  body {
    margin: 0;
    font-family: "Segoe UI", sans-serif;
    background: url("autumn.jpeg") no-repeat center center fixed;
    background-size: cover;
    display: flex;
    align-items: flex-start;
    justify-content: center;
    padding: 40px;
  }

  .app {
    max-width: 1200px;
    width: 100%;
    background: #FFE4B5;
    border-radius: 20px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    display: grid;
    grid-template-columns: 340px 1fr;
    overflow: hidden;
  }

  .left {
    background: #FFE4B5;
    padding: 24px;
    border-right: 2px solid #DEB887;
  }

  h1 {
    font-size: 22px;
    color: #4D220E;
    text-align: center;
    margin-bottom: 20px;
  }

  label {
    font-size: 14px;
    color: #4D220E;
    display: block;
    margin-bottom: 6px;
  }

  input[type=file],
  select,
  input[type=range],
  input[type=number] {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid #D2B48C;
    border-radius: 8px;
    background: #FFF8DC;
    color: #4D220E;
  }

  .btn {
    background: #8B4513;
    color: #fff;
    border: none;
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.2s, transform 0.1s;
  }

  .btn:hover {
    background: #A0522D;
    transform: scale(1.05);
  }

  .btn.secondary {
    background: #CD853F;
  }

  .btn.secondary:hover {
    background: #D2691E;
  }

  .row {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .preview {
    background: #FFE4B5;
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 18px;
  }

  .canwrap {
    display: flex;
    gap: 20px;
    justify-content: center;
  }

  .canwrap > div {
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }

  .small {
    font-size: 13px;
    font-weight: 500;
    color: #4D220E;
  }

  canvas {
    max-width: 100%;
    height: auto;
    background: #111827;
    border-radius: 12px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.25);
    transition: transform 0.2s;
  }

  canvas:hover {
    transform: scale(1.02);
  }

  .meta {
    font-size: 13px;
    color: #4D220E;
  }

  .two-cols {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
  }

  .sample-list {
    display: none;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
    justify-content: center;
  }

  .sample-list.active {
    display: flex;
  }

  .sample-list button {
    padding: 6px 10px;
    border-radius: 8px;
    border: none;
    background: #8B4513;
    color: #fff;
    font-size: 13px;
    cursor: pointer;
    transition: background 0.2s, transform 0.1s;
  }

  .sample-list button:hover {
    background: #A0522D;
    transform: translateY(-1px);
  }

  .footer {
    text-align: center;
    color: #4D220E;
    font-size: 13px;
    margin-top: 8px;
  }
</style>
</head>
<body>
  <div class="app">
    <div class="left">
      <h1>üçÅ Image Processing Lab</h1>

      <label>–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</label>
      <input id="fileInput" type="file" accept="image/*" />

      <div class="row" style="margin-top:10px">
        <button id="btnToggleSamples" class="btn">–¢–µ—Å—Ç–æ–≤—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</button>
        <button id="btnDownload" class="btn secondary">–°–∫–∞—á–∞—Ç—å</button>
      </div>

      <div id="sampleList" class="sample-list"></div>

      <label style="margin-top:12px;">–ú–µ—Ç–æ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–∏</label>
      <select id="method"></select>

      <div id="params"></div>

      <div class="row" style="margin-top:14px">
        <button id="applyBtn" class="btn">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
        <button id="resetBtn" class="btn secondary">–°–±—Ä–æ—Å–∏—Ç—å</button>
      </div>
    </div>

    <div class="preview">
      <div class="canwrap">
        <div>
          <div class="small">–û—Ä–∏–≥–∏–Ω–∞–ª</div>
          <canvas id="origCanvas" width="640" height="360"></canvas>
        </div>
        <div>
          <div class="small">–†–µ–∑—É–ª—å—Ç–∞—Ç</div>
          <canvas id="outCanvas" width="640" height="360"></canvas>
        </div>
      </div>

      <div class="two-cols">
        <div class="meta" id="origMeta">‚Äî</div>
        <div class="meta" id="outMeta">‚Äî</div>
      </div>

      <div class="footer">¬© 2025 Image Processing Lab</div>
    </div>
  </div>

<script>
/* ---------- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UI ---------- */
const fileInput = document.getElementById('fileInput');
const origCanvas = document.getElementById('origCanvas');
const outCanvas = document.getElementById('outCanvas');
const methodSel = document.getElementById('method');
const paramsDiv = document.getElementById('params');
const applyBtn = document.getElementById('applyBtn');
const resetBtn = document.getElementById('resetBtn');
const btnToggleSamples = document.getElementById('btnToggleSamples');
const btnDownload = document.getElementById('btnDownload');
const origMeta = document.getElementById('origMeta');
const outMeta = document.getElementById('outMeta');
const sampleList = document.getElementById('sampleList');

const oc = origCanvas.getContext('2d');
const out = outCanvas.getContext('2d');

let originalImage = null;
let originalImageData = null;
let lastResultData = null;

/* ---------- helpers ---------- */
function updateMeta() {
  if (!originalImageData) { origMeta.textContent = '–ò—Å—Ö–æ–¥–Ω–∏–∫: ‚Äî'; outMeta.textContent = '–†–µ–∑—É–ª—å—Ç–∞—Ç: ‚Äî'; return; }
  origMeta.textContent = `–ò—Å—Ö–æ–¥–Ω–∏–∫: ${originalImageData.width}√ó${originalImageData.height}, ${originalImageData.data.length/ (originalImageData.width*originalImageData.height) * 8} bit (RGBA buffer)`;
  if (lastResultData) outMeta.textContent = `–†–µ–∑—É–ª—å—Ç–∞—Ç: ${lastResultData.width}√ó${lastResultData.height}`; else outMeta.textContent = '–†–µ–∑—É–ª—å—Ç–∞—Ç: ‚Äî';
}

function clamp(v,min=0,max=255){ return v<min?min:(v>max?max:v); }

/* ---------- parameter UI ---------- */
function renderParams() {
  const method = methodSel.value;
  paramsDiv.innerHTML = '';

  if (method === 'brightness') {
    paramsDiv.innerHTML = `
      <label>–Ø—Ä–∫–æ—Å—Ç—å (offset) <input id="p_brightness" type="range" min="-255" max="255" value="0" /></label>
      <div class="small">Offset: <span id="p_brightness_val">0</span></div>
    `;
    const r = paramsDiv.querySelector('#p_brightness');
    const v = paramsDiv.querySelector('#p_brightness_val');
    r.addEventListener('input', ()=> v.textContent = r.value);
  } else if (method === 'contrast') {
    paramsDiv.innerHTML = `
      <label>–ö–æ–Ω—Ç—Ä–∞—Å—Ç (factor) <input id="p_contrast" type="range" min="0" max="3" step="0.01" value="1" /></label>
      <div class="small">–§–∞–∫—Ç–æ—Ä: <span id="p_contrast_val">1</span></div>
    `;
    const r = paramsDiv.querySelector('#p_contrast');
    const v = paramsDiv.querySelector('#p_contrast_val');
    r.addEventListener('input', ()=> v.textContent = r.value);
  } else if (method === 'local_mean') {
    paramsDiv.innerHTML = `
      <label>–û–∫–Ω–æ (size) <input id="p_win" type="number" min="3" max="201" step="2" value="25" /></label>
      <label>–°–¥–≤–∏–≥ (C) <input id="p_C" type="number" step="1" value="0" /></label>
    `;
  } else if (method === 'niblack') {
    paramsDiv.innerHTML = `
      <label>–û–∫–Ω–æ (size) <input id="p_win" type="number" min="3" max="201" step="2" value="25" /></label>
      <label>k (–æ–±—ã—á–Ω–æ -0.2..-0.5) <input id="p_k" type="number" step="0.05" value="-0.2" /></label>
    `;
  } else if (method === 'sauvola') {
    paramsDiv.innerHTML = `
      <label>–û–∫–Ω–æ (size) <input id="p_win" type="number" min="3" max="201" step="2" value="25" /></label>
      <label>k (0..0.5) <input id="p_k" type="number" step="0.01" value="0.34" /></label>
      <label>R (dynamic range, default 128) <input id="p_R" type="number" step="1" value="128" /></label>
    `;
  } else if (method === 'stretch') {
    paramsDiv.innerHTML = `
      <div class="small">–õ–∏–Ω–µ–π–Ω–æ–µ —Ä–∞—Å—Ç—è–∂–µ–Ω–∏–µ –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞: –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞—Å—Ç—è–≥–∏–≤–∞–µ—Ç min‚Üí0 –∏ max‚Üí255</div>
    `;
  } else {
    paramsDiv.innerHTML = `<div class="small">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –¥–ª—è —ç—Ç–æ–≥–æ –º–µ—Ç–æ–¥–∞</div>`;
  }
}

/* ---------- image loading & canvas ---------- */
function fitCanvasToImage(img, canvas) {
  // keep width <= 640
  const maxW = 640;
  let w = img.width, h = img.height;
  if (w > maxW) { const r = maxW / w; w = maxW; h = Math.round(h*r); }
  canvas.width = w; canvas.height = h;
}

function loadImageIntoCanvas(img) {
  originalImage = img;
  fitCanvasToImage(img, origCanvas);
  fitCanvasToImage(img, outCanvas);
  oc.clearRect(0,0,origCanvas.width,origCanvas.height);
  oc.drawImage(img,0,0, origCanvas.width, origCanvas.height);
  originalImageData = oc.getImageData(0,0,origCanvas.width, origCanvas.height);
  // clear output
  out.clearRect(0,0,outCanvas.width,outCanvas.height);
  lastResultData = null;
  updateMeta();
}

/* ---------- core processing helpers ---------- */

function getGrayArray(imageData) {
  const w = imageData.width, h = imageData.height;
  const data = imageData.data;
  const gray = new Float32Array(w*h);
  for (let i=0, p=0;i<w*h;i++, p+=4) {
    // lum formula
    gray[i] = 0.299*data[p] + 0.587*data[p+1] + 0.114*data[p+2];
  }
  return {gray, w, h};
}

function putGrayToRGBA(gray, w, h) {
  const id = new ImageData(w,h);
  const outd = id.data;
  for (let i=0, p=0;i<w*h;i++, p+=4) {
    const v = clamp(Math.round(gray[i]));
    outd[p]=outd[p+1]=outd[p+2]=v;
    outd[p+3]=255;
  }
  return id;
}

/* efficient integral images for mean/std computations */
function integralImage(gray, w, h) {
  const I = new Float64Array((w+1)*(h+1));
  for (let y=1;y<=h;y++) {
    let rowSum = 0;
    for (let x=1;x<=w;x++) {
      const val = gray[(y-1)*w + (x-1)];
      rowSum += val;
      I[y*(w+1)+x] = I[(y-1)*(w+1)+x] + rowSum;
    }
  }
  return I;
}
function integralImageSq(gray, w, h) {
  const I = new Float64Array((w+1)*(h+1));
  for (let y=1;y<=h;y++) {
    let rowSum = 0;
    for (let x=1;x<=w;x++) {
      const val = gray[(y-1)*w + (x-1)];
      rowSum += val*val;
      I[y*(w+1)+x] = I[(y-1)*(w+1)+x] + rowSum;
    }
  }
  return I;
}
function sumRegion(I, w, x1,y1,x2,y2) {
  // I is (w+1)-width integral image, coords 1-based
  const W = w+1;
  return I[y2*W + x2] - I[y1-1*W + x2] - I[y2*W + x1-1] + I[(y1-1)*W + x1-1];
}

/* ---------- Algorithms ---------- */

// Per-pixel ops (operate on RGBA ImageData)
function negative(imageData) {
  const outId = new ImageData(imageData.width, imageData.height);
  const d = imageData.data, od = outId.data;
  for (let i=0;i<d.length;i+=4) {
    od[i]   = 255 - d[i];
    od[i+1] = 255 - d[i+1];
    od[i+2] = 255 - d[i+2];
    od[i+3] = d[i+3];
  }
  return outId;
}
function brightness(imageData, offset) {
  const outId = new ImageData(imageData.width, imageData.height);
  const d = imageData.data, od = outId.data;
  for (let i=0;i<d.length;i+=4) {
    od[i] = clamp(d[i] + offset);
    od[i+1] = clamp(d[i+1] + offset);
    od[i+2] = clamp(d[i+2] + offset);
    od[i+3] = d[i+3];
  }
  return outId;
}
function contrast(imageData, factor) {
  // factor: 1 = unchanged, >1 increase
  // use formula: new = ( (pixel-128)*factor ) + 128
  const outId = new ImageData(imageData.width, imageData.height);
  const d = imageData.data, od = outId.data;
  for (let i=0;i<d.length;i+=4) {
    od[i]   = clamp((d[i]-128)*factor + 128);
    od[i+1] = clamp((d[i+1]-128)*factor + 128);
    od[i+2] = clamp((d[i+2]-128)*factor + 128);
    od[i+3] = d[i+3];
  }
  return outId;
}
function linearStretch(imageData) {
  // convert to grayscale then stretch each channel by same min/max from luminance
  const w=imageData.width,h=imageData.height,d=imageData.data;
  let min=255,max=0;
  for (let i=0;i<d.length;i+=4) {
    // luminance
    const lum = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
    if (lum < min) min = lum;
    if (lum > max) max = lum;
  }
  if (max<=min) return imageData;
  const outId = new ImageData(w,h); const od = outId.data;
  for (let i=0;i<d.length;i+=4) {
    // stretch each channel proportionally to luminance shift
    od[i] = clamp((d[i]-min)*255/(max-min));
    od[i+1] = clamp((d[i+1]-min)*255/(max-min));
    od[i+2] = clamp((d[i+2]-min)*255/(max-min));
    od[i+3] = d[i+3];
  }
  return outId;
}

/* Local thresholding algorithms (work on grayscale arrays) */
function localMeanThreshold(gray,w,h,win,C=0) {
  // for every pixel compute mean in window and threshold
  const half = Math.floor(win/2);
  const I = integralImage(gray,w,h);
  const out = new Float32Array(w*h);
  for (let y=0;y<h;y++){
    const y1 = Math.max(0,y-half), y2 = Math.min(h-1,y+half);
    for (let x=0;x<w;x++){
      const x1 = Math.max(0,x-half), x2 = Math.min(w-1,x+half);
      const area = (x2-x1+1)*(y2-y1+1);
      const sum = I[(y2+1)*(w+1)+(x2+1)] - I[(y1)*(w+1)+(x2+1)] - I[(y2+1)*(w+1)+(x1)] + I[(y1)*(w+1)+(x1)];
      const mean = sum/area;
      const idx = y*w+x;
      out[idx] = gray[idx] > mean - C ? 255 : 0;
    }
  }
  return out;
}

function niblackThreshold(gray,w,h,win,k=-0.2) {
  const half = Math.floor(win/2);
  const I = integralImage(gray,w,h);
  const I2 = integralImageSq(gray,w,h);
  const out = new Float32Array(w*h);
  for (let y=0;y<h;y++){
    const y1 = Math.max(0,y-half), y2 = Math.min(h-1,y+half);
    for (let x=0;x<w;x++){
      const x1 = Math.max(0,x-half), x2 = Math.min(w-1,x+half);
      const area = (x2-x1+1)*(y2-y1+1);
      const sum = I[(y2+1)*(w+1)+(x2+1)] - I[(y1)*(w+1)+(x2+1)] - I[(y2+1)*(w+1)+(x1)] + I[(y1)*(w+1)+(x1)];
      const sum2 = I2[(y2+1)*(w+1)+(x2+1)] - I2[(y1)*(w+1)+(x2+1)] - I2[(y2+1)*(w+1)+(x1)] + I2[(y1)*(w+1)+(x1)];
      const mean = sum/area;
      const varr = (sum2/area) - (mean*mean);
      const std = varr>0?Math.sqrt(varr):0;
      const thresh = mean + k * std;
      out[y*w+x] = gray[y*w+x] > thresh ? 255 : 0;
    }
  }
  return out;
}

function sauvolaThreshold(gray,w,h,win,k=0.34,R=128) {
  const half = Math.floor(win/2);
  const I = integralImage(gray,w,h);
  const I2 = integralImageSq(gray,w,h);
  const out = new Float32Array(w*h);
  for (let y=0;y<h;y++){
    const y1 = Math.max(0,y-half), y2 = Math.min(h-1,y+half);
    for (let x=0;x<w;x++){
      const x1 = Math.max(0,x-half), x2 = Math.min(w-1,x+half);
      const area = (x2-x1+1)*(y2-y1+1);
      const sum = I[(y2+1)*(w+1)+(x2+1)] - I[(y1)*(w+1)+(x2+1)] - I[(y2+1)*(w+1)+(x1)] + I[(y1)*(w+1)+(x1)];
      const sum2 = I2[(y2+1)*(w+1)+(x2+1)] - I2[(y1)*(w+1)+(x2+1)] - I2[(y2+1)*(w+1)+(x1)] + I2[(y1)*(w+1)+(x1)];
      const mean = sum/area;
      const varr = (sum2/area) - (mean*mean);
      const std = varr>0?Math.sqrt(varr):0;
      const thresh = mean * (1 + k * ((std / R) - 1));
      out[y*w+x] = gray[y*w+x] > thresh ? 255 : 0;
    }
  }
  return out;
}

/* ---------- main apply logic ---------- */

function applySelected() {
  if (!originalImageData) return alert('–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–Ω–∞—á–∞–ª–∞');

  const method = methodSel.value;
  let resultImageData = null;

  if (['negative','brightness','contrast','stretch'].includes(method)) {
    if (method === 'negative') resultImageData = negative(originalImageData);
    else if (method === 'brightness') {
      const offset = Number(document.getElementById('p_brightness').value || 0);
      resultImageData = brightness(originalImageData, offset);
    } else if (method === 'contrast') {
      const factor = Number(document.getElementById('p_contrast').value || 1);
      resultImageData = contrast(originalImageData, factor);
    } else if (method === 'stretch') {
      resultImageData = linearStretch(originalImageData);
    }
    // put to outCanvas
    out.clearRect(0,0,outCanvas.width,outCanvas.height);
    // ensure output canvas same size as orig
    outCanvas.width = originalImageData.width;
    outCanvas.height = originalImageData.height;
    out.putImageData(resultImageData, 0, 0);
    lastResultData = resultImageData;
    updateMeta();
    return;
  }

  // For local/adaptive thresholds: compute gray, then thresholds -> binary image
  const {gray,w,h} = getGrayArray(originalImageData);
  const win = Number((document.getElementById('p_win') && document.getElementById('p_win').value) || 25);

  if (method === 'local_mean') {
    const C = Number(document.getElementById('p_C')?.value || 0);
    const bin = localMeanThreshold(gray,w,h,win,C);
    const id = putGrayToRGBA(bin,w,h);
    outCanvas.width = w; outCanvas.height = h;
    out.putImageData(id,0,0);
    lastResultData = id;
    updateMeta();
    return;
  }
  if (method === 'niblack') {
    const k = Number(document.getElementById('p_k')?.value || -0.2);
    const bin = niblackThreshold(gray,w,h,win,k);
    const id = putGrayToRGBA(bin,w,h);
    outCanvas.width = w; outCanvas.height = h;
    out.putImageData(id,0,0);
    lastResultData = id;
    updateMeta();
    return;
  }
  if (method === 'sauvola') {
    const k = Number(document.getElementById('p_k')?.value || 0.34);
    const R = Number(document.getElementById('p_R')?.value || 128);
    const bin = sauvolaThreshold(gray,w,h,win,k,R);
    const id = putGrayToRGBA(bin,w,h);
    outCanvas.width = w; outCanvas.height = h;
    out.putImageData(id,0,0);
    lastResultData = id;
    updateMeta();
    return;
  }
}

/* ---------- reset & download ---------- */
function reset() {
  if (!originalImage) return;
  loadImageIntoCanvas(originalImage);
}
function downloadResult() {
  if (!lastResultData) return alert('–°–Ω–∞—á–∞–ª–∞ –ø—Ä–∏–º–µ–Ω–∏—Ç–µ –º–µ—Ç–æ–¥');
  const a = document.createElement('a');
  a.href = outCanvas.toDataURL('image/png');
  a.download = 'result.png';
  a.click();
}

/* ---------- File input ---------- */
fileInput.addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if (!f) return;
  const img = new Image();
  const url = URL.createObjectURL(f);
  img.onload = () => { loadImageIntoCanvas(img); URL.revokeObjectURL(url); };
  img.onerror = ()=>{ alert('–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ'); URL.revokeObjectURL(url); };
  img.src = url;
});

/* ---------- sample images generator ---------- */
function makeCanvasCopy(w=512,h=320, drawFn) {
  const c = document.createElement('canvas'); c.width=w;c.height=h;
  const g = c.getContext('2d');
  drawFn(g,w,h);
  const img = new Image();
  img.src = c.toDataURL('image/png');
  return img;
}
function createSamples() {
  sampleList.innerHTML = '';
  const samples = [];

  // Low contrast gradient (useful for stretching)
  samples.push({name:'Low contrast', img: makeCanvasCopy(640,360,(g,w,h)=>{
    const grd = g.createLinearGradient(0,0,w,0);
    grd.addColorStop(0,'#808080'); grd.addColorStop(1,'#b0b0b0');
    g.fillStyle = grd; g.fillRect(0,0,w,h);
    g.fillStyle='rgba(0,0,0,0.25)'; g.fillRect(0,0,w,h);
  })});

  // Gaussian-ish blur of a detailed pattern (approx with box blur)
  samples.push({name:'Blurred pattern', img: makeCanvasCopy(640,360,(g,w,h)=>{
    for (let y=0;y<h;y+=6) for (let x=0;x<w;x+=6) {
      const c = Math.floor(128 + 120*Math.sin((x+y)/14));
      g.fillStyle = `rgb(${c},${(c+60)%255},${(200-c)%255})`;
      g.fillRect(x,y,6,6);
    }
    // quick box-blur: draw scaled smaller then back
    const tmp = document.createElement('canvas'); tmp.width=320; tmp.height=180;
    const tg = tmp.getContext('2d'); tg.drawImage(g.canvas,0,0,tmp.width,tmp.height);
    g.clearRect(0,0,w,h); g.drawImage(tmp,0,0,w,h);
  })});

  // Salt and pepper (binary noise) over text-like gradient
  samples.push({name:'Salt&Pepper', img: makeCanvasCopy(640,360,(g,w,h)=>{
    g.fillStyle='#ddd'; g.fillRect(0,0,w,h);
    g.fillStyle='#222'; g.font='bold 72px serif'; g.fillText('Test', 80, 180);
    // add noise
    const id = g.getImageData(0,0,w,h); for (let i=0;i<id.data.length;i+=4) {
      if (Math.random() < 0.04) { const v = Math.random()<0.5?0:255; id.data[i]=id.data[i+1]=id.data[i+2]=v; }
    } g.putImageData(id,0,0);
  })});

  // Gaussian noise on photo-like pattern
  samples.push({name:'Noisy', img: makeCanvasCopy(640,360,(g,w,h)=>{
    // create simple scene
    for (let y=0;y<h;y++) {
      const r = Math.round(120 + 100*Math.sin(y/30));
      g.fillStyle = `rgb(${r},${r/1.3},${255-r/2})`; g.fillRect(0,y,w,1);
    }
    const id = g.getImageData(0,0,w,h);
    for (let i=0;i<id.data.length;i+=4) {
      const n = (Math.random()-0.5)*40;
      id.data[i]=clamp(id.data[i]+n); id.data[i+1]=clamp(id.data[i+1]+n); id.data[i+2]=clamp(id.data[i+2]+n);
    } g.putImageData(id,0,0);
  })});

  // Add UI buttons
  samples.forEach(s=>{
    const btn = document.createElement('button');
    btn.textContent = s.name;
    btn.onclick = ()=> {
      const img = s.img;
      img.onload = ()=> loadImageIntoCanvas(img);
      // if already loaded, call directly:
      if (img.complete) loadImageIntoCanvas(img);
    };
    sampleList.appendChild(btn);
  });
}

/* ---------- wiring ---------- */
methodSel.addEventListener('change', renderParams);
applyBtn.addEventListener('click', applySelected);
resetBtn.addEventListener('click', reset);
btnDownload.addEventListener('click', downloadResult);

// –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É –ø–æ–∫–∞–∑—ã–≤–∞–µ–º/–ø—Ä—è—á–µ–º —Å–ø–∏—Å–æ–∫
btnToggleSamples.addEventListener('click', () => {
  // –µ—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç ‚Äî —Å–æ–∑–¥–∞—ë–º
  if (!sampleList.children.length) createSamples();
  sampleList.classList.toggle('active');
});

/* initial */
/* ---------- –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –º–µ—Ç–æ–¥–æ–≤ ---------- */
const methods = [
  { value: 'negative', label: '–ò–Ω–≤–µ—Ä—Å–∏—è (Negative)' },
  { value: 'brightness', label: '–Ø—Ä–∫–æ—Å—Ç—å (Brightness offset)' },
  { value: 'contrast', label: '–ö–æ–Ω—Ç—Ä–∞—Å—Ç (Contrast factor)' },
  { value: 'stretch', label: '–õ–∏–Ω–µ–π–Ω–æ–µ –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ (Linear stretch)' },
  { value: 'local_mean', label: '–õ–æ–∫–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥ (Local mean)' },
  { value: 'niblack', label: '–ü–æ—Ä–æ–≥ –ù–∏–±–ª–∞–∫–∞ (Niblack)' },
  { value: 'sauvola', label: '–ü–æ—Ä–æ–≥ –°–∞—É–≤–æ–ª–∞ (Sauvola adaptive)' }
];

methodSel.innerHTML = '';
methods.forEach(m => {
  const opt = document.createElement('option');
  opt.value = m.value;
  opt.textContent = m.label;
  methodSel.appendChild(opt);
});

renderParams();
updateMeta();


</script>
</body>
</html>
